# -*- eval: (save-excursion (org-babel-goto-named-src-block "workshopPreamble") (org-babel-execute-src-block)) -*-
#+TITLE:     Einführung in C
#+AUTHOR:    Jörg Reuter
#+EMAIL:     joerg@reuter.sc
#+DATE:      

#+PROPERTY: exports both
#+EXCLUDE_TAGS: noexport mitsetup
#+SETUPFILE: ../workshopPreamble.org

#+name: workshopPreamble
#+begin_src emacs-lisp :exports none :results silent :tangle no
  (load-file "../setupEnvironment.el")
#+end_src

#+name: setupR
#+begin_src R :exports none :tangle no :results silent
  rm(list=ls())
  .First <- function() {
    options(width=70)
    options(useFancyQuotes=FALSE)
    options(show.signif.stars=FALSE)
    options(scipen = 10)
    options(digits = 3)
  }
#+end_src
* Einführung in C
C ist eine Programmiersprace die kompiliert wird. Bei C wird zwischen Sourcecode und dem Binary unterschieden. Der Sourcecode ist das Programm, dass in einem Editor in C geschrieben wird. Es ist von menschen les- und verstehbar. Durch das kompilieren wird aus dem Sourcecode das Binary erzeugt. Das Binary wird für jede Plattform getrennt erzeugt und ist ausführbar. Der Inhalt des Binaries kann nicht mehr von menschen gelesen und verstanden werden. Sourcefiles von C-Programmen bekommen die Endung .c.

In Linux heißt das Programm zum kompilieren gcc. GCC installieren wir mit dem Befehl

#+begin_src
sudo apt install gcc
#+end_src

** Hallo Welt

#+begin_src C:export both
#include <stdio.h>

int main(void){
    printf("Hallo Welt!\n");
    return 0;
}
#+end_src

Ich habe das Programm hallo_welt.c genannt. 

Mit dem Befehl

#+begin_src
gcc hallo_welt.c
#+end_src

wird unaer Quellcode eingelsen und kompiliert. Es entsteht eine Datei mit dem Namen a.out. Das rogramm könen wir ausführen mit dem Befehl:

#+begin_src
./a.out
#+end_src

Mit dem Parameter -o können wir den Namen der Ausgabedatei festlegen:

#+begin_src
gcc -o hallo_welt hallo_welt.c
#+end_src

Die erste Zeile unseren Programms ist eine Anweisung an den Preprozessor. Der Preprozessor ist Bestandteil von gcc. Der Befehl #include <stdio.h> sorgt dafür, dass die Datei stdio.h vor dem Compilieren der Datei zur Verfügung steht. Die Datei stdio.h enthält Standardbefehle um die Ein- und Ausgabe von zeichen zu steuern. I unserem Programm greifen wir auf den Befehl printf aus der Datei stdio.h zurück. Diese Dateien heißen Headerdateien und erhalten daher die Endung .h. Die Endungen sind nicht zwingend, sie sind aber sehr verbreitet um den Mitmenschen das Lesen von Programmen zu erleichtern. 

Die Zeile int void mein leitet die Main-Funktion ein. Die Mainfunktion ist der Punkt, der bei starten des Programms als erstes ausgeführt wird. Die Main-Funktion muss in jedem C-Programm vorhanden sein. Alle Befehle zwischen { und } gehören zur Main-Funktion. In diesem Programm der Befehl printf(...) und return 0. Am Semikolon nach printf erkennen wir, dass jeder Befehl mit einem Semikolon abgeschlossen werden muss. Der Befehl printf gibt die Zeile in den """ aus. Das "\n" bedeutet "Neue Zeile". 

** Ausgabe
1.) Führe das Programm bitte ohne "\n" aus. Was fällt Dir auf?
2.) Bitte benenne die Zeichenkette "main" in "erste" um. Was fällt Dir auf?
3.) Gebe bitte mit dem Befehl "cat" die Datei mit dem Sourcecode im Terminal aus und danach die kompilierte Datei. Was fällt Dir auf?

Der Befehl return 0 gibt an das Betriebssystem zurück: Das Programm wurde fehlerfrei ausgeführt. Ein Wert von nicht 0 würde dem Betriebssystem einen Fehler signalisieren.

Mit dem Befehl

#+begin_src
echo $?
#+end_src

kann man sich den letzten Exit-Status eines Programms ausgeben lassen.

** Aufabe

1.) Lasse Dir den Exit-Code der letzten Ausführung des C-Programms ausgeben.
2.) Verändere das Programm so, dass eine "1" zurückgegeben wird. Überprüfe die Ausgabe.
3.) Lösche die Zeile mit dem Befehl "return" komplett. gibt es ein Kompilierungsfehler? Welcher Exit-Code wird zurück gegeben?



 
* TDD
TDD ist eine wundervolle Methode um Code zu schreiben. TDD basiert darauf, dass zuerst klar und abprüfbar definiert wird, welches Verhalten dieses Programm haben soll. Das Programm an sich wird als eine Blackbox angesehen, die bei bestimmten Eingabewerten bestimmte Ausgabewerte liefert. Die Anforderungen werden in sogenannten Tests definiert. Das bedeutet, dass für jede Anforderung ein Test geschrieben wird, der diese Anforderung abprüft. Dieses Verfahren hilft dabei:

- das Problem klar zu beschreiben
- Bei Veränderungen am Code sofort zuerkenen ist, ob sich das Verhalten des Programms ändert.

Computer sind heute so schnell, dass die Test meistens im Hintergrund ablaufen, ohne das der Programmierer dies mitbekommt. Bei grossen Projekten werden die Tests über Nacht durchgeführt.

Als erstes schlagen alle Tests fehl, weil noch kein Code vorhanden ist. Der erste Schritt ist es, dass Problem irgendwie so zu lösen, so das der Test keinen Fehler ausgibt. Danach kann der Code beliebig optimiert werden, ohne das die Funktion nach aussen veränder wird.

Um TDD einfach mit C anzuwenden wird ein Framework verwendet. Dies liegt einfach daran, dass C eine sehr alte Programmiersprache ist (fast 50 Jahre: https://de.wikipedia.org/wiki/C_(Programmiersprache)). Im laufe der Zeit ändern sich Sachen aber bei Embedded Systems (eingebettet Systeme) ist die Zeit auf Grund der widrigen Umständen wie hoher Kostendruck, sehr energiesparendes Design, sehr kleine Abmessungen und daher sehr schwache Auslegung von Prozessor und Speicher etc. ist die Entwicklung der Programmiersprache nicht auf dem aktuellen Stand. 

Gerade dieses stehen bleiben in der Entwicklung läst C als nichtgeeignet erscheinen, um eine Programmiersprache zu lernen. Auf der anderen Seite hat C eine herausragende Bedeutung im Segment der IoT und der kelinen Geräten. Gerade da wo bei der Leistung um jedes Milliwatt gekämpft wird, weil die Geräte oft 24h am Tag und 365 Tage im Jahr im Betrieb sind. Wo die Software mit Prozessoren zurecht kommen muss, die noch im einstelligen MHZ-Bereich ihren Dienst tun und mit KBytes statt GBytes an RAM wahre Wunder vollbringen sollen. In Bereichen, indenen die Geräte möglichst verschwinden sollen und sich keiner dafür interessiert wie Funksteckdosen, Babyphone, WebCam,Armbanduhr, Radio, Waschmaschine, Auto, Heizungsregelung etc. gesteuert werden. Aber gerade diese Durchsetzung der Umgebung einer modernen Gesellschaft mit den kleinen Helfern macht sie zahlenmässig bedeutend. So bedeutend, dass man sich als angehender Fachinformatiker oder Systemelektroniker zumindest ein paar Eigenschaften der Programmiersprache zu eigen gemacht haben sollte.

** Installation von Ceedling unter Ubuntu 16.04

Als erstes müssen wir Rubby installieren. Wir nehmen als Vorlage den Blog von gorails.com (https://gorails.com/setup/ubuntu/16.04):

#+begin_src
sudo apt-get update
sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
git clone https://github.com/rbenv/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
echo 'eval "$(rbenv init -)"' >> ~/.bashrc
exec $SHELL
git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bashrc
exec $SHELL
rbenv install 2.3.1
ruby -v
gem install bundler
gem install ceedling
#+end_src

Mit den Befehlen ist Ceedling komplett installiert und kann mit folgendem Befehl aufgerufen werden:

#+begin_src
gem install ceedling
#+end_src

und wir bekommen  die möglichen Funktionen von Ceedling angezeigt.

#+begin_src
Welcome to Ceedling!
Commands:
  ceedling example PROJ_NAME [DEST]  # new specified example project (in DEST, if specified)
  ceedling examples                  # list available example projects
  ceedling help [COMMAND]            # Describe available commands or one specific command
  ceedling new PROJECT_NAME          # create a new ceedling project
#+end_src



























** Unity
Wir brauchen als erstes einen Compiler mit Hilfswerkzeugen:

#+begin_src
apt install gcc make
#+end_src

Wir beginnen TDD mit dem Framework Unity (http://www.throwtheswitch.org/unity) 
Erster Schritt ist das Klonen eines Github-Repositories:

#+begin_src
git clone https://github.com/ThrowTheSwitch/Unity.git
#+end_sc

Im Verzeichnis Unity liegen unter src die benötigten Dateien. Die anderen Dateien sind nur schückendes Beiwerk.

Wir erzeugen als nächstes ein Verzeichnis im gleichen Pfad, indem wir das git clone - Kommando abgesetzt haben. Der Name des Verzeichnisses ist beliebig, wir nennen es im Text das Projektverzeichnis.

In diesem Verzeichnis klonen wir auch das Repository mit den Lernmaterialien:

#+begin_src
https://github.com/joergre/workshops.git
#+end_src

In dem neuen Verzeichnis workshops findet Ihr unter LF6/unity/ ein makfile. Dieses kopiert Ihr bitte in Euren Projektordner:

#+begin_src
cp makefile ../../../Projekt
#+end_src




* Cleanup							   :noexport:
#+name: cleanitallup
#+begin_src R 
  rm(list=ls())
#+end_src

#+RESULTS: cleanitallup
#+begin_example
> rm(list=ls())
> 
#+end_example

* Ideen :nonexport

