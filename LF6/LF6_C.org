# -*- eval: (save-excursion (org-babel-goto-named-src-block "workshopPreamble") (org-babel-execute-src-block)) -*-
#+TITLE:     Einführung in Python
#+AUTHOR:    Jörg Reuter
#+EMAIL:     joerg@reuter.sc
#+DATE:      

#+PROPERTY: exports both
#+EXCLUDE_TAGS: noexport mitsetup
#+SETUPFILE: ../workshopPreamble.org

#+name: workshopPreamble
#+begin_src emacs-lisp :exports none :results silent :tangle no
  (load-file "../setupEnvironment.el")
#+end_src

#+name: setupR
#+begin_src R :exports none :tangle no :results silent
  rm(list=ls())
  .First <- function() {
    options(width=70)
    options(useFancyQuotes=FALSE)
    options(show.signif.stars=FALSE)
    options(scipen = 10)
    options(digits = 3)
  }
#+end_src
* TDD
TDD ist eine wundervolle Methode um Code zu schreiben. TDD basiert darauf, dass zuerst klar und abprüfbar definiert wird, welches Verhalten dieses Programm haben soll. Das Programm an sich wird als eine Blackbox angesehen, die bei bestimmten Eingabewerten bestimmte Ausgabewerte liefert. Die Anforderungen werden in sogenannten Tests definiert. Das bedeutet, dass für jede Anforderung ein Test geschrieben wird, der diese Anforderung abprüft. Dieses Verfahren hilft dabei:

- das Problem klar zu beschreiben
- Bei Veränderungen am Code sofort zuerkenen ist, ob sich das Verhalten des Programms ändert.

Computer sind heute so schnell, dass die Test meistens im Hintergrund ablaufen, ohne das der Programmierer dies mitbekommt. Bei grossen Projekten werden die Tests über Nacht durchgeführt.

Als erstes schlagen alle Tests fehl, weil noch kein Code vorhanden ist. Der erste Schritt ist es, dass Problem irgendwie so zu lösen, so das der Test keinen Fehler ausgibt. Danach kann der Code beliebig optimiert werden, ohne das die Funktion nach aussen veränder wird.

Um TDD einfach mit C anzuwenden wird ein Framework verwendet. Dies liegt einfach daran, dass C eine sehr alte Programmiersprache ist (fast 50 Jahre: https://de.wikipedia.org/wiki/C_(Programmiersprache)). Im laufe der Zeit ändern sich Sachen aber bei Embedded Systems (eingebettet Systeme) ist die Zeit auf Grund der widrigen Umständen wie hoher Kostendruck, sehr energiesparendes Design, sehr kleine Abmessungen und daher sehr schwache Auslegung von Prozessor und Speicher etc. ist die Entwicklung der Programmiersprache nicht auf dem aktuellen Stand. 

Gerade dieses stehen bleiben in der Entwicklung läst C als nichtgeeignet erscheinen, um eine Programmiersprache zu lernen. Auf der anderen Seite hat C eine herausragende Bedeutung im Segment der IoT und der kelinen Geräten. Gerade da wo bei der Leistung um jedes Milliwatt gekämpft wird, weil die Geräte oft 24h am Tag und 365 Tage im Jahr im Betrieb sind. Wo die Software mit Prozessoren zurecht kommen muss, die noch im einstelligen MHZ-Bereich ihren Dienst tun und mit KBytes statt GBytes an RAM wahre Wunder vollbringen sollen. In Bereichen, indenen die Geräte möglichst verschwinden sollen und sich keiner dafür interessiert wie Funksteckdosen, Babyphone, WebCam,Armbanduhr, Radio, Waschmaschine, Auto, Heizungsregelung etc. gesteuert werden. Aber gerade diese Durchsetzung der Umgebung einer modernen Gesellschaft mit den kleinen Helfern macht sie zahlenmässig bedeutend. So bedeutend, dass man sich als angehender Fachinformatiker oder Systemelektroniker zumindest ein paar Eigenschaften der Programmiersprache zu eigen gemacht haben sollte.

** Installation von Ceedling unter Ubuntu 16.04

Als erstes müssen wir Rubby installieren. Wir nehmen als Vorlage den Blog von gorails.com (https://gorails.com/setup/ubuntu/16.04):

#+begin_src
sudo apt-get update
sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
git clone https://github.com/rbenv/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
echo 'eval "$(rbenv init -)"' >> ~/.bashrc
exec $SHELL
git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bashrc
exec $SHELL
rbenv install 2.3.1
ruby -v
gem install bundler
gem install ceedling
#+end_src

Mit den Befehlen ist Ceedling komplett installiert und kann mit folgendem Befehl aufgerufen werden:

#+begin_src
gem install ceedling
#+end_src

und wir bekommen  die möglichen Funktionen von Ceedling angezeigt.

#+begin_src
Welcome to Ceedling!
Commands:
  ceedling example PROJ_NAME [DEST]  # new specified example project (in DEST, if specified)
  ceedling examples                  # list available example projects
  ceedling help [COMMAND]            # Describe available commands or one specific command
  ceedling new PROJECT_NAME          # create a new ceedling project
#+end_src



























** Unity
Wir brauchen als erstes einen Compiler mit Hilfswerkzeugen:

#+begin_src
apt install gcc make
#+end_src

Wir beginnen TDD mit dem Framework Unity (http://www.throwtheswitch.org/unity) 
Erster Schritt ist das Klonen eines Github-Repositories:

#+begin_src
git clone https://github.com/ThrowTheSwitch/Unity.git
#+end_sc

Im Verzeichnis Unity liegen unter src die benötigten Dateien. Die anderen Dateien sind nur schückendes Beiwerk.

Wir erzeugen als nächstes ein Verzeichnis im gleichen Pfad, indem wir das git clone - Kommando abgesetzt haben. Der Name des Verzeichnisses ist beliebig, wir nennen es im Text das Projektverzeichnis.

In diesem Verzeichnis klonen wir auch das Repository mit den Lernmaterialien:

#+begin_src
https://github.com/joergre/workshops.git
#+end_src

In dem neuen Verzeichnis workshops findet Ihr unter LF6/unity/ ein makfile. Dieses kopiert Ihr bitte in Euren Projektordner:

#+begin_src
cp makefile ../../../Projekt
#+end_src




* Cleanup							   :noexport:
#+name: cleanitallup
#+begin_src R 
  rm(list=ls())
#+end_src

#+RESULTS: cleanitallup
#+begin_example
> rm(list=ls())
> 
#+end_example

* Ideen :nonexport

