# -*- eval: (save-excursion (org-babel-goto-named-src-block "workshopPreamble") (org-babel-execute-src-block)) -*-
#+TITLE:     Einführung in Docker
#+AUTHOR:    Jörg Reuter
#+EMAIL:     joerg@reuter.sc
#+DATE:      
#+PROPERTY: exports both
#+EXCLUDE_TAGS: noexport mitsetup

#+SETUPFILE: ../workshopPreamble.org

#+name: workshopPreamble
#+begin_src emacs-lisp :exports none :results silent :tangle no
  (load-file "../setupEnvironment.el")
#+end_src

#+name: setupR
#+begin_src R :exports none :tangle no :results silent
  rm(list=ls())
  .First <- function() {
    options(width=70)
    options(useFancyQuotes=FALSE)
    options(show.signif.stars=FALSE)
    options(scipen = 10)
    options(digits = 3)
  }
#+end_src

* Einführung in Docker
** Warum Docker
Docker ist eine Anwendung die es ermöglicht Anwendungen in Containern zu virtualisieren. Docker ist in diese Sicht nicht etwas neues, es gibt bereits seit sehr langer Zeit die Möglichkeit des Einsatzes von Containern unter Linux wie z.B. OpenVZ. Der Hauptunterschied zu anderen Virtualisierungen ist, dass nicht der Schwerpunkt auf die Virtualisierung von Betriebssystemen gelegt wird, sondern von Anwendungen. Das zeigt sich z.B. daran, dass Container normalerweise keine öffentliche IP-Adresse haben und nur über einen festgelegten Port über die IP des "Hostsystems" erreichbar sind. Auch auf hub.docker.com werden eher Anwendungen angeboten und nicht Betriebssysteme. Wenn ein Webserver gebraucht wird, ist es nicht interessant auf welchen Linux-Dervat er installiert wurde, sondern das er sicher läuft und die benötigten Dienste zur Verfügung stellt.
Aber der Reihe nach.
*** Vorteile von Docker
- Docker ist unabhängig vom Betriebssystem. Es wird unterstützt von: 
    - allen Linux Distributionen,
    - Microsoft-Betriebssystemen (seit 2016),  
    - OS X.

- Vorteile gegenüber anderen Virtualisierungslösungen:
    - Benötigt keine besondere Hardware oder CPU-Erweiterungen.
    - Effizienter als herkömmliche Virtualisierungslösungen.
    - Weitergabe von Containern sehr leicht möglich (nur ein Textfile).
    - Einfache Überprüfung, wie der Container aufgesetzt wurde (alle Befehle stehen in dem Textfile).
    - Kostenlos Nutzbar.
    - Plattformunabhängige Container. Keine Abhängigkeiten zum Hostsystem.
    - Einfaches Clustering von Systemen.
    - Einfache Versionsverwaltung. Jeder Schritt kann rückgängig gemacht werden und jeder Schritt wird aufgezeichnet.

** Docker Begriffe
*** Images
Ein Image ist portable und kann zwischen Systemen ausgetauscht werden. Es kann aus einem Container erstellt werden und stellt so einen Snapshot dar.

*** Container
Ein Container braucht ein Image. Der Container ist ein gestartetes Image und existiert nur, solange die Instanz läuft. Beim herunterfahren des Containers können die Änderungen  die durch Laufzeit des Containers eingetreten sind im Image hinzugefügt werden. Images haben immer eine Version und es werden nur die Unterschiede zur vorhergehenden Version gespeichert. Ein Image kann von mehreren Containern geteilt werde.

** Arten von Virtualisierung (Prüfungsrelevant!)
*** TYP 1 (Bare Metall)

*** TYP 2

** Installation von Docker

Die Installation von Docker für alle gängigen Betriebssysteme ist hier erklärt: https://docs.docker.com/ 

** Exkurs: Installation von gateone unter Docker

Im Unterricht setzen wir GateOne ein. Gateone stellt einen HTML5-Client für ssh zur Verfügung. Gateone läuft in einem Docker-Container und wird wie folgt installiert:

#+name: GateOne
#+BEGIN_EXAMPLE
docker run -d --name=gateone -p 8000:8000 liftoff/gateone
#+END_EXAMPLE

Mit diesem Befehl läuft der Docker-Container und der Port wird per HTTPS auf Port 8000 zur Verfügung gestellt. Port 8000 weil der port 443 bereits auf dem Server genutzt wird. 

Um den Service auf Port 443 zur Verfügung zu stellen verwenden wir mod_proxy.

*** Installation von mod_proxy

#+name:mod_proxy
#+BEGIN_EXAMPLE
apt-get install libapache2-mod-proxy-html 
a2enmod proxy
a2enmod proxy_html
a2enmod proxy_http 
#+END_EXAMPLE

*** Einrichrichtung der NameVirtualHost-Direktive

Wir legen im Verzeichnsis /etc/apache2/sites-avaible ein Datei an mit dem Namen 004-gateone.conf:

#+name:NameVirtualHist-Direktive
#+BEGIN_EXAMPLE
<VirtualHost *:443>
  ServerName ssh.fbs-fulda.info
  ServerAdmin joerg@reuter.sc
  ProxyRequests Off
  <Proxy *>
    Order deny,allow
    Allow from all
  </Proxy>
    ProxyPass / https://127.0.0.1:8000/
    ProxyPassReverse / https://127.0.0.1:8000/
</VirtualHost>
#+END_EXAMPLE

Jetzt müssen wir die Konfiguration noch aktivieren:

#+name:aktivieren
#+BEGIN_EXAMPLE
a2ensite 004-gateone
service apache2 reload
#+END_EXAMPLE

** Docker Container unter Linux 

Wir laden das Image von Ubuntu 14.04 herunter:

#+name: setupR
#+BEGIN_EXAMPLE
docker pull ubuntu:14.04
#+END_EXAMPLE

Anzeige der lokal vorhanden Images:

#+name: local_Images
#+BEGIN_EXAMPLE
docker images
#+END_EXAMPLE

Zugriff auf die Shell

#+name: dockerrun
#+BEGIN_EXAMPLE
docker run -t -i ubuntu:14.04 bash
#+END_EXAMPLE

Wir benötigen jetzt eine zweite Konsole die nicht im Docker-Container angemeldet ist. Diese Konsole wird benötigt um den Docker-Container zu verwalten.
Von einer zweiten Konsole:
#+name: dockerps
#+BEGIN_EXAMPLE
docker ps
#+END_EXAMPLE

um sich den Namen des laufenden Docker Container anzeigen zu lassen 
Docker Container anhalten (hungy_euklid ist der Name der jeweiligen Maschine):

#+name: dockerstop
#+BEGIN_EXAMPLE
docker stop hungry_euclid
#+END_EXAMPLE

Gestoppten Container neu starten:

#+name: dockerstart
#+BEGIN_EXAMPLE
docker start -i hungry_euclid
#+END_EXAMPLE

Container löschen:

#+name: dockerloeschen
#+BEGIN_EXAMPLE
docker stop hungry_euclid
docker rm hungry_euclid
#+END_EXAMPLE

*** Container suchen

Ein beliebter Webserver ist Nginx. Wir schauen uns jetzt alle verfügbaren Images von Nginx an:

#+name: dockersearch
#+BEGIN_EXAMPLE
docker search ngninx
#+END_EXAMPLE

Wir sehen vir Spalten: Den Namen (vor dem Schrägstrichsteht der Autor und danach der name des Images. Gibt es keinen / dann ist es ein offizielles Image des Entwicklers.), eine Beschreibung des Images, die Anzahl der Sterne und in der letzten Spalte die Kennzeichnung offizieller Images.

#+name:searchausg
#+BEGIN_EXAMPLE
NAME                          DESCRIPTION                                     STARS     OFFICI

AL   AUTOMATED

nginx                         Official build of Nginx.                        6302      [OK]

jwilder/nginx-proxy           Automated Nginx reverse proxy for docker c...   1059

     [OK]

richarvey/nginx-php-fpm       Container running Nginx + PHP-FPM capable ...   398
#+END_EXAMPLE

Nginx Image herunterladen, Conntainer starten und den Namen nginx geben:

#+name: dockerrunnginx
#+BEGIN_EXAMPLE
docker run -d --name nginx nginx
#+END_EXAMPLE

Jetzt überprüfen wir ob der Container auch läuft:

#+name: dockerpss
#+BEGIN_EXAMPLE
docker ps -s
#+END_EXAMPLE

** Aufagbe

a) Suche bitte die Images von CentOS und Apache mit den besten Bewertungen heraus.

b) Lade bitte das Image für NginX (neuste Version) herunter

Bei dem Befehl docker pull von Aufgabe b ensteht folgende Ausgabe:

#+name: dockerpullnginx
#+BEGIN_EXAMPLE
Using default tag: latest
latest: Pulling from library/nginx
e6e142a99202: Pull complete
8c317a037432: Pull complete
af2ddac66ed0: Pull complete
#+END_EXAMPLE

Wir sehen, dass das Image aus 3 Teilen besteht: Das zugrundliegende Basisimage, dem Server NginX und als letztes die Konfigurationsdateien. Jeder Teil ist für sich. Wenn das nächste Image die gleiche Installationsvorlage verwendet, dann wird dieser Teil nur einmal gespeichert.


Alle laufenden und gestoppten Container löschen:

#+name: dockerdelete
#+BEGIN_EXAMPLE
docker ps -qa|xargs docker rm -f
#+END_EXAMPLE


* Zum eigenen Image
Mit dem Befehl
#+name: dockerinfo
#+begin_src bash :export both
  docker info
#+end_src

#+name: dockerinfo_result
#+BEGIN_EXAMPLE
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.10.3
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins: 
 Volume: local
 Network: null host bridge
Kernel Version: 4.7.0-coreos
Operating System: CoreOS 1122.2.0 (MoreOS)
OSType: linux
Architecture: x86_64
CPUs: 1
Total Memory: 493.2 MiB
Name: fbs-01
ID: UEJT:QG6A:VS7A:HUWD:6J6D:PPVX:C5DY:XS5R:GHQ7:2RWT:7PLT:DDE5
#+end_example
überprüfen wir, ob Docker installiert ist und ordnungsgemäß läuft.
Um ein neues Image zu erstellen, gibt es zwei Wege:

- docker commit
- docker build

Die mächtigste und übliche Methode ist der Weg über den Befehl docker build. 

Beachte: Wir bauen keine komplett neuen Images. Der Weg ist vielmehr, dass wir ein bestehendes Image (z.B. Ubuntu) entsprechend anpassen!

** Docker Hub account
Eine wichtige und großartige Sache ist das teilen von Docker Images. Wir können dies über den offitiellen Docker Hub machen oder aber über unser eigene Registry. Um es einfach zu machen, erstellen wir uns einen Account bei Docker Hub (https://hub.docker.com). 
** Login
Wir melden uns jetzt von der Konsole aus bei Docker Hub an:

#+name: dockerinfo
#+begin_src bash :export both
  docker login
#+end_src

#+RESULTS:
#+begin_example
Username: joergre
Password: 
Email: joerg@reuter.sc
WARNING: login credentials saved in /home/core/.docker/config.json
Login Succeeded
#+end_example

Mit dem Befehl
#+name: dockerinfo
#+begin_src bash :export both
  docker logout
#+end_src

#+RESULTS:
#+begin_example
Remove login credentials for https://index.docker.io/v1/
#+end_example

melden wir uns von Docker ab. Aber wir melden uns sofort wieder an, wir möchte ja mit Docker Hub arbeiten.

** Docker commit
Wie bereits erwähnt, der eher unübliche Weg. Das Kapitel dient nur dazu, zu zeigen, wie man es auch machen kann.

Wir fangen immer mit einem bestehenden Image an. Bei Docker commit starten wir das Image und erstellen so einen Container:
#+name: dockerinfo
#+begin_src bash :export both
  docker run -i -t ubuntu /bin/bash
#+end_src

#+RESULTS:
#+begin_example
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

cad964aed91d: Pull complete 
3a80a22fea63: Pull complete 
50de990d7957: Pull complete 
61e032b8f2cb: Pull complete 
9f03ce1741bf: Pull complete 
Digest: sha256:28d4c5234db8d5a634d5e621c363d900f8f241240ee0a6a978784c978fe9c737
Status: Downloaded newer image for ubuntu:latest
root@f39032b9f532:/# 
#+end_example

Den Befehl haben wir ja bereits öfters ausgeführt. Insofern sind wir (hoffentlich) nicht überrascht, dass wir in dem Container angemeldet sind.
Als nächste Schritt installieren wir den Webserver Apache. Zuerst müssen wir dazu das Repository der Packete aktualisieren:

#+name: dockerinfo
#+begin_src bash :export both
  apt -yqq update
#+end_src

#+RESULTS:
#+begin_example
6 packages can be upgraded. Run 'apt list --upgradable' to see them.
#+end_example

Wir könnten jetzt ein apt upgrade ausführen, dass lassen wir aber und fahren fort mit der Installation:

#+name: dockerinfo
#+begin_src bash :export both
  apt -yqq install apache2
#+end_src

Die Ausgabe erspare ich mir an dieser Stelle. Wir möchten nun den Zustand des Containers sichern um ihn später weiterverwenden zu können. Wir loggen uns mit exit aus:
#+begin_src bash :export both
  exit
#+end_src

#+RESULTS:
#+begin_example
exit
core@fbs-01 ~ $
#+end_example

*** Aufgabe
Finde heraus, welche Bedeutung die Parameter -yqq bei dem Installationsprozess haben.

Unser Container ist jetzt beendet. Wir suchen uns jetzt die Container-ID:
#+begin_src bash :export both
  docker ps
#+end_src

#+RESULTS:
#+begin_example
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f39032b9f532        ubuntu              "/bin/bash"         13 minutes ago      Exited (0) 3 minutes ago                       pensive_stallman
#+end_example

und führen jetzt einen docker commit durch:

#+begin_src bash :export both
  docker commit -m "apache2" -a "jreuter"  pensive_stallman jreuter/ubuapache2
#+end_src

#+RESULTS:
#+begin_example
sha256:91d4e09127ec25aa2dce9f86afa78bdb436aae6adde787142c54a99766b182ee
#+end_example

Ihr benötigt für das commit die Container-ID und (optional) Euren Benutzername von Docker HUB und durch "/" getrennt ein Imagenamen den Ihr frei wählen könnt. Sinnvoller Weise sollte der Name so gewählt werden, dass man auch nächste Woche noch eine Idee über den Inhalt des Containers hat.
Nun möchten wir uns das Ergebniss auch anschauen:

#+begin_src bash :export both
  docker images
#+end_src

#+RESULTS:
#+begin_src
root@proxmox:~# docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
jreuter/ubuapache2      latest              e4ad07191c42        6 minutes ago       340MB
#+end_src


Wir ersdtellen aus dem neuen Images wieder einen Container:

#+RESULTS:
#+begin_src
docker run -it jreuter/ubuapache2 /bin/bash
#+end_src

Wir untersuchen den neuen Container dahin gehend ob der Webserver apache2 installiert wurde.


Mit docker inspect können wir das Image näher untersuchen:
#+begin_src bash :export both
  docker inspect jreuter/ubuapache2
#+end_src

#+RESULTS:
#+begin_src
[
    {
        "Id": "sha256:cfca430f55847bbf5f3b54a70325adde853cf1447d1524afa104199a5addff85",
        "RepoTags": [
            "jreuter/ubuapache2"
        ],
        "RepoDigests": [],
        "Parent": "sha256:c73a085dc3782b3fd4c032971c76d6afb45fa3728a048175c8c77d7403de5f21",
        "Comment": "Mein erstes eigene Image. Das war ja einfach",
        "Created": "2016-10-11T04:40:50.411198103Z",
        "Container": "f39032b9f5329f63d73f7bfc70b0fa3f5b88c29ddd98cd75ab832a629e2b113c",
        "ContainerConfig": {
            "Hostname": "f39032b9f532",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "ubuntu",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {},
            "StopSignal": "SIGTERM"
        },
        "DockerVersion": "1.10.3",
        "Author": "Jörg Reuter",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 265202837,
        "VirtualSize": 265202837,
        "GraphDriver": {
            "Name": "overlay",
            "Data": {
                "RootDir": "/var/lib/docker/overlay/9c634d9573d15e4da697c5a58bbeee4ceb677ae5a7afab6263e6c9b15b6d13f1/root"
            }
        }
    }
]
#+end_src

Eine Übersicht über alle Parameter findet Ihr hier: http://54.71.194.30:4016/reference/commandline/cli/#commit

** Docker build

Für dieses vorgehen legen wir ein Verzeichnis an, indem wir unser Image erstellen:

#+name: mkdir
#+begin_src bash
mkdir build
cd build
#+end_src

Wir öffnen eine Datei mit dem namen Dockerfile mit unserem Lieblingseditor (Achtung: Die Datei muss genau so heißen!!!)

#+name: dockerapache2
#+begin_src bash :export both
FROM ubuntu
MAINTAINER jreuter <joerg@reuter.sc>
RUN apt-get -yqq update
RUN apt-get -yqq install apache2
#+end_src



Das Script wird ausgeführt mit folgendem Befehl:

#+name: ubuntuapachev2
#+begin_src bash :export both
docker build -t"jreuter/ubuntuapache2:v2" .
#+end_src

Wir sehen dann den Prozess Schritt für Schritt. Mit einem 

#+name: dockerimages
#+begin_src bash :export both
docker images
#+end_src

sehen wir unser neues Image:

#+RESULTS:
#+begin_src bash
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
jreuter/ubuntuapache2   v2                  d1dcc98d7d2e        13 seconds ago      258MB
#+end_example

Wir starten einen Container aus dem neuen Image:

#+name: dockerrun
#+begin_src bash :export both
docker run -it jreuter/ubuntuapache2:v2 /bin/bash
#+end_src

und überprüfen, dass Apache2 richtig installiert worden ist.

** Aufgabe
Nenne Gründe, warum docker build die besssere Methode ist um neue Images zu erstellen.


* Zum Schluss

** Helfe mir, den Kurs besser zu machen!
- Bitte nehme Dir einen Moment Zeit und fülle das Feedback-Formular aus.
- Der Kurs existiert für Dich -- sage mir, was Du brauchst! 
- http://goo.gl/forms/04cJw2mtBB

** Weitere Informationsquellen
* Cleanup							   :noexport:
#+name: cleanitallup
#+begin_src R 
  rm(list=ls())
#+end_src

#+RESULTS: cleanitallup
#+begin_example
> rm(list=ls())
> 
#+end_example
